[{"content":"","date":"2024-11-10","externalUrl":null,"permalink":"/blog/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"2024-11-10","externalUrl":null,"permalink":"/blog/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-11-10","externalUrl":null,"permalink":"/blog/","section":"Yuki","summary":"","title":"Yuki","type":"page"},{"content":" 前言 # 此前我并没有搭建个人网站的经验。搭建博客的原因，请参考搭建博客初衷。本文旨在记录从调研、安装到网站搭建完成的整个过程，同时分享一些过程中遇到的坑点。网站基于hugo框架，使用Blowfish主题模板搭建，并通过GitHub Pages进行托管。\nHugo简介 # hugo 是一款开源的静态网站生成器，以其惊人的速度和高度的灵活性著称，特别适合用于构建个人博客。相比传统的前端三件套（HTML、CSS、JavaScript）或像 Vue 和 React 这样的前端框架，Hugo 提供的脚手架工具能够帮助用户快速构建丰富多样、视觉精美的网站。即使不具备前端开发经验，用户只需编辑配置文件并编写 Markdown 文件即可轻松创建内容。\nmy-site/ ├── archetypes/ │ └── default.md ├── assets/ ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ ├── themes/ └── hugo.toml 模板是什么 # hugo主题商店提供了多种多样的模板，大家可以根据喜好选择模板下载并使用，本网站使用的模板为Blowfish\n快速开始 # 关于如何安装与使用blowfish模板，作者已经给出了详细的中文文档，具体流程本文不再赘述，下面列举关键内容\n安装Hugo # 在使用blowfish前，需确保本机已正确安装hugo，安装教程见安装与配置\n使用Blowfish构建网站 # Blowfish提供了工具Blowfish-Tools，用于创建一个新的 Hugo 项目、安装 Blowfish 主题并设置配置文件\n截止到2024.11.10，该脚手架仍存在一定的bug，因此不建议使用 文档提供三种方式安装Blowfish模板，包括Git子模块安装，Hugo模块安装、手动文件复制。其中Git子模块链接到的是Github源码，并非放在releases中稳定的版本，可能出现bug，不建议使用，笔者曾经被此硬控一下午；Hugo使用GO来初始化，使用前需确保安装GO，略显麻烦，不建议使用；手动文件复制，即在releases中下载latest版本，然后将其复制到themes目录下，建议使用。\n配置模板 # 按照文档教程，你的 config 目录看起来应该是这样：\nconfig/_default/ ├─ hugo.toml ├─ languages.en.toml ├─ markup.toml ├─ menus.en.toml ├─ module.toml # 通过 Hugo 模块安装 └─ params.toml en代表主语言为英文，若想修改为中文，需在hugo.toml文件中配置defaultContentLanguage = \u0026quot;zh-cn\u0026quot;,hasCJKLanguage = true，并将languages.en.toml与menus.en.toml依次替换成languages.zh-cn.toml、menus.zh-cn.toml，对应的语言文件见https://github.com/nunocoracao/blowfish/tree/main/exampleSite/config/_default。\n若选择手动复制文件方式构建网站，config目录应为：\nconfig/_default/ ├─ hugo.toml ├─ languages.zh-cn.toml ├─ markup.toml ├─ menus.zh-cn.toml └─ params.toml 在完成基本配置后，需着重关注hugo.toml文件，根据不同的Github部署方式，baseURL有如下两种配置方式\n使用Github部署方式一，需修改为https://{username}.github.io/，比如baseURL = \u0026quot;https://zhihengning.github.io/\u0026quot; 使用Github部署方式二，需修改为https://{username}.github.io/{repository name}/，比如baseURL = \u0026quot;https://zhihengning.github.io/blog/\u0026quot; 其余的配置参数，可参考入门指南与详细配置\n本地运行 # 在根目录下运行hugo serve命令，出现下面内容即为启动成功\nBuilt in 205 ms Environment: \u0026#34;development\u0026#34; Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:56518/blog/ (bind address 127.0.0.1) Press Ctrl+C to stop Github部署 # 方式一 # 按照本地运行启动项目后，在根目录查看生成的public文件夹，里面包括由hugo框架生成的html文件及图片资源，将其发布到Github上即可，具体流程如下：\n在Github上创建仓库github.{username}.io，其中username为你的用户名，例如github.ZhihengNing.io 在public目录下初始化git仓库，并将其推送到远程仓库github.{username}.io 浏览器输入https://github.{username}.io/访问网站 以上流程看起来简单，但仍有诸多不便。例如：每次push到远程仓库，需要在本地运行一遍生成public目录；Github page部署与本地运行两种方式存在本质差别，Blowfish部分的功能无法正常显示。\n方式二 # 在main分支下使用Github Actions自动构建项目，创建新的分支存储构建资源（public文件夹），最后使用Github pages自动部署页面。具体流程如下：\n在Github上创建仓库，如blog\n在根目录下初始化git仓库\n可能需要通过.gitignore文件排除public文件夹 创建存储构建资源分支，如page\n按照文档给出的Github page的部署教程，在.github/workflows中创建gh-pages.yml，并修改publish_branch为上一步的构建资源分支，内容如下：\n# .github/workflows/gh-pages.yml name: GitHub Pages on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: page publish_dir: ./public 访问 Github 代码库的 Settings \u0026gt; Pages 部分，它应该被设置为构建资源分支\n将本地文件push到远程仓库的main分支下，此时Github会依次启动两个任务流Github Pages与pages-build-deployment，分别用于构建资源并推送到page分支、部署page分支的静态资源\n在浏览器输入https://github.{username}.io/blog 访问网站\n踩过的坑 # 部署失败 # 若在部署网页时日志提示403，无写入权限\nfatal: unable to access \u0026#39;https://github.com/ZhihengNing/blog.git/\u0026#39;: The requested URL returned error: 403 Error: Action failed with \u0026#34;The process \u0026#39;/usr/bin/git\u0026#39; failed with exit code 128\u0026#34; 应配置对应的代码库，按照Settings -\u0026gt; Action -\u0026gt; General -\u0026gt; Workflow permissions的顺序打开，勾选Read and write permissions\n公式渲染 # Blowfish提供了KaTex的公式渲染组件，使用方式见数学表达式。由于大部分人包括笔者编写markdown时使用typora，它仅仅支持MathType的书写方式，即使用$或$$包裹公式，导致公式无法在网页中渲染。于是笔者提供了python的脚本文件，用于将公式转换为KaTex的形式，并提供bat脚本，让本地构建运行前先执行python脚本。\n","date":"2024-11-10","externalUrl":null,"permalink":"/blog/learn/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E6%B5%81%E7%A8%8B/","section":"学习","summary":"记录第一次搭建网站的流程与心得","title":"如何搭建个人网站","type":"learn"},{"content":"欢迎来到我的学习小站！很高兴你的来访。笔者是一名计算机专业的学生，这一部分记录的是本科及研究生期间学习或科研的成果，包括但不限于数学、编程语言、操作系统、数据结构、计算机网络、设计模式、机器学习、深度学习等专业知识\n","date":"2024-11-10","externalUrl":null,"permalink":"/blog/learn/","section":"学习","summary":"","title":"学习","type":"learn"},{"content":" 前言 # 经过前两节内容的学习（计算机网络中的加密传输（一），计算机网络中的加密传输（二）），相信大家已经对计算机网络中的加密传输有了一定的了解。今天笔者想聊一聊Github中关于ssh的配置，深入剖析其原理，并给出计算机网络加密常用的思想与范式。\nSSH协议 # 配置方式 # 加密原理 # ","date":"2024-10-15","externalUrl":null,"permalink":"/blog/learn/computer-network/github-auth/","section":"学习","summary":"Github SSH连接方式与原理的解读（待定）","title":"Github中SSH连接方式及原理","type":"learn"},{"content":"","date":"2024-10-15","externalUrl":null,"permalink":"/blog/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-10-15","externalUrl":null,"permalink":"/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"计算机网络","type":"tags"},{"content":"","date":"2024-10-15","externalUrl":null,"permalink":"/blog/series/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/","section":"Series","summary":"","title":"计算机网络中的加密传输","type":"series"},{"content":" 前言 # JWT（JSON Web Token）是基于JSON实现Token的方式。JWT是基于开放标准（RFC 7519）实现的紧凑且自包含的，用于在各方以JSON形式传输的信息。该信息可以被信任与验证，因为它也是一种数字签名。JWT可以使用HMAC算法或RSA、ESDSA的公钥\\私钥进行签名。JWT常常被应用于以下两个场景：\n授权：这是JWT最常用的场景，用户登陆后可获取JWT，并在后续的每个请求携带他，这将允许用户访问该令牌允许的路由、服务、资源。JWT被广泛应用于单点登录中，具有开销小、轻松跨域使用的特点。 信息交换：JSON网络令牌是各方安全传输信息的好方法，使用公私钥对的方法加密时，可以保证持有密钥的人才可以解码数据（参考SSL/TLS加密传输协议）。此外，由于签名是使用标头和有效负载计算的，你还可以验证内容没有被篡改。 JWT结构 # 在其紧凑的形式中，JSON Web令牌由由点（.）分隔的三部分组成，它们是：\n表头 有效载荷 签名 因此，JWT通常如下所示。\nxxxxx.yyyyy.zzzzz\n让我们分解不同的部分。\n表头 # 标头通常由两部分组成：令牌的类型，即JWT，以及正在使用的签名算法，如HMAC SHA256或RSA。\n例如：\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } 然后，这个JSON被Base64Url编码以形成JWT的第一部分。\n有效载荷 # 令牌的第二部分是有效负载，其中包含声明。声明是关于实体（通常是用户）和附加数据的声明。声明有三种类型：注册声明、公共声明和私有声明。一般只会添加用户不敏感信息，如ID，名字和权限等，如下所示：\n{ \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;admin\u0026#34;: true } 对有效载荷进行Base64Url编码可形成JSON Web Token的第二部分。\n请注意，对于签名令牌，此信息虽然受到防篡改保护，但任何人都可以读取。除非加密，否则不要将机密信息放入JWT的有效载荷或表头元素中。\n签名 # 要创建签名部分，您必须获取编码的表头、编码的有效载荷、密钥、表头中指定的算法，并对其进行签名。\n例如，如果您想使用HMAC SHA256算法，签名将通过以下方式创建：\nHMACSHA256( base64UrlEncode(header) + \u0026#34;.\u0026#34; + base64UrlEncode(payload), secret) 其中，密钥secret存储在服务器，不在网络进行传播。签名用于验证消息在此过程中没有更改，并且在使用私钥签名的令牌的情况下，它还可以验证JWT的发送者是否是它所说的发送者。\n对签名进行Base64Url编码可形成JSON Web Token的第三部分。\n最后将表头、有效载荷和签名三者以点连接在一起，构成JSON Web Token\n如何使用 # 用户端在登录成功后，服务器会根据用户信息生成JWT令牌，并返回给客户端。之后用户向后端请求接口时，一般在请求头携带token，后端接收请求后，在拦截器中解析token，确认用户登录状态和判断权限。\nAuthorization: Bearer \u0026lt;token\u0026gt; JWT与SSL/TLS # JWT与SSL/TLS加密传输协议中的数字签名类似，具有不可篡改但容易获取的特点，细节与作用却有所不同。区别与联系如下：\nJWT用户信息与TLS数字证书公钥是透明的，但TLS中的预主密钥是不可见，由公钥加密的。原因在于在授权场景中，用户信息只包含用户名、用户ID等不敏感信息，使用Base64编码，即使黑客获取了也无济于事；而TLS的预主密钥用于保障数据的安全传输，是隐私数据。 JWT与TLS数字证书都采用自校验的方式来防止内容被篡改，从而保证JWT是由Server端发布，TLS数字证书是由CA机构发布的，都具有真实性。 JWT用于标识用户的登录状态与授权状态，Server端一旦发布了便无法对其管控，直至过期，这也说明了任何人获取后都可依靠其获得权限，存在一定的风险；数字证书由CA机构统一颁布，其有效性得到有效的管控，若签名通过后只能说明公钥没有被篡改，不标识任何状态。 参考 # https://jwt.io/introduction\n","date":"2024-10-14","externalUrl":null,"permalink":"/blog/learn/computer-network/jwt/","section":"学习","summary":"JWT加密原理及过程的学习笔记","title":"JSON Web Token学习","type":"learn"},{"content":" 前言 # HTTP（超文本传输协议）作为一种应用层协议，现已广泛应用于计算机进程之间的通信。然而，由于其在网络中以明文形式传输数据，对于安全性要求高的信息，如军事机密、交易数据、用户密码等，存在严重的隐私和安全风险。在这种背景下，HTTPS协议应运而生，HTTPS在HTTP基础上引入了SSL/TLS加密协议，通过密钥对传输数据进行加密，并结合数字签名技术确保访问站点的真实性和合法性。即便黑客等不法分子接获数据，也无法在短时间内解密，从而极大地提升了数据的安全性。\n接下来，我们将深入剖析HTTPS中的SSL(TLS协议、数字证书等核心概念，探讨其发展背景、技术改进历程及实际应用效果，逐步引导大家全面理解“加密”背后的技术原理和过程。（注：SSL\\TLS协议的真实流程与本文可能略有出入，但大致相同）\nSSL/TLS # 原理及流程 # Secure Socket Layer译为安全套接层（下面简称SSL），是在TCP/IP上实现的公开密钥安全协议，由Netscape公司率先采用。大致分为三个版本，第一个版本由于其存在严重的安全漏洞，从未公开发布，其余的版本2.0，3.0也因为存在诸多安全隐患，已在2000年被淘汰。之后IETF（互联网工程任务组）标准化SSL后提出了Transport Layer Security（传输层安全，下面简称TLS），彻底将SSL取代。TLS提供了更为安全和标准化的加密通讯方式，它修复了SSL的安全问题，并提供向后兼容性，TLS与SSL的主要区别在于它们的安全特性和标准支持，随着TLS的版本迭代，每一代TLS协议都在强化安全措施去除已知漏洞，并支持更先进的加密算法和技术。TLS的迭代过程这里不再赘述，本文关注的是更为通用的算法设计思想及细节。\n鉴于部分读者没有学过密码学相关课程，也不清楚加密算法的流程，下面对加密/解密过程下一个不严谨（但正确）的定义\n加密的本质就是使用密钥1，通过加密算法对数据进行加密；而解密使用密钥2，通过解密算法进行解密\n抛开算法实现细节不谈，客户端与服务端在正式通信之前，理论上只要告诉对方支持何种加密算法和密钥（下面称会话密钥）就可以了。加密算法的种类不多，并且是通用的，全世界都知道；而会话密钥理论上只能服务端和客户端持有，这样才能保证经过会话密钥加密的数据能准确加\\解密，并且具有安全性（黑客窃取后无法加\\解密）。那么，如何保证服务端和客户端持有相同的会话密钥呢？有个简单的方法是客户端或服务端生成会话密钥，再通过网络发送给对方。由于会话密钥很长，传输会浪费网络资源，所以客户端与服务端一般交换一个随机数，再使用密钥派生函数（如HMAC）生成最终的会话密钥，其中随机数被称为预主密钥，流程如下图所示\n聪明的读者肯定发现了问题，如果这个预主密钥（2）在中途被窃取了怎么办。简单，加密不久好了，加密之后黑客就无法破解了。TLS也确实是这样做的：服务器生成一个密钥（1），将其发送给客户端（2），客户端使用这个密钥加密预主密钥得到加密结果（3、4），服务端再使用这个密钥解密加密结果，从而得到预主密钥（5），这个过程被成为对称加密，如下图所示\n这里涉及了一个新名词：对称加密，即使用相同的密钥对同一个数据进行加密解密。\n如果按照上述流程对预主密钥进行加密，中间产生的密钥再被窃取了怎么办，再如法炮制这种对称加密的过程又会继续产生一个中间的密钥，套娃无法解决我们的问题。于是，引入非对称加密：服务器生成一个公私钥对（即公钥和密钥）（1），将公钥发送给客户端（2），客户端使用公钥加密预主密钥得到加密结果（3、4），服务端再使用私钥解密加密结果（5），从而得到预主密钥。非对称加密相对于对称加密，增加了公钥私钥两个概念，这保证了持有其中一个密钥（如公钥）只能解密另一个密钥（私钥）加密的数据，同样地，持有密钥只能解密公钥加密的数据，这个过程相对于非对称加密更安全。由于公钥在网络中传输，而私钥留在服务器，这意味着即使黑客截取了公钥，仍然无法通过公钥对加密的预主密钥进行解密，而私钥才可以。非对称加密流程如下：\nTLS协议中选择在网络中传输公钥的原因是：公钥长度短，能减少传输资源消耗\n以上的过程看似天衣无缝，但却在公钥传输过程中出现了纰漏，黑客获取公钥无效，但可以篡改并伪装网络请求，截获服务器发送的公钥（2），并将其替换成“其他公钥”（如黑客生成的公私钥对），并再次截获客户端通过公钥加密的预主密钥（4），对其进行解密，从而得到预主密钥。\nps：黑客同样可以截获公钥（2）和用公钥加密的预主密钥（4），并将加密后的预主密钥替换为加密后的“黑客预主密钥”。当服务器成功解密后，将使用“黑客的预主密钥”生成会话密钥，此时客户端依然使用自己的预主密钥生成会话密钥。由于两个会话密钥不同，首次数据交换时便无法正确解密数据，从而导致会话终止。 综上，无论使用对称加密还是非对称加密，我们都不能保证传输预主公钥的绝对安全性。一方面，对称加密保证了公钥（密钥）在传输过程中的不可篡改性，但其可查看性导致了预主密钥的轻松破解；另一方面，非对称加密保证了公钥（密钥）在传输过程中的“不可见性”（这里并非真正的不可见，而是就算获取到了公钥，没有私钥仍然无法破解预主密钥），但其可篡改性导致了预主密钥的轻松破解。下面我们介绍一种方式，即数字证书来保证非对称加密下的绝对安全性。\n数字证书 # 数字证书是网站持有人员向CA机构（Certificate Authority，即证书授权中心）申请的证书，包含个人或者组织网络数字身份（如区域信息、邮箱、域名等）和公开密钥等信息。具体过程如下：CA机构使用CA私钥对服务器的公钥进行加密，然后计算网络数字身份与加密后的公钥的哈希值，并将两者合并生成证书指纹。最后，将网络数字身份、加密后的公钥信息和证书指纹合并生成数字证书，并将其发送给网站。\nCA机构是‌数字证书发行的唯一机构，负责为电子商务交易中的用户发放数字证书，确保公钥的合法性和安全性。CA机构，也称为证书授权中心（Certificate Authority），是电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。CA机构为每个使用公开密钥的用户发放一个数字证书，这些证书通过CA机构的‌数字签名，确保了攻击者无法伪造和篡改证书。‌ 那么如何使用数字证书呢？在建立TLS连接后（具体将在完整流程中说明），服务器给客户端发送数字证书。客户端首先通过hash算法进行证书签名，以确保其完整性（如分别计算CA私钥加密的公钥、证书内容的hash值，将其合并与证书指纹进行对比），接着便可通过操作系统自带的CA公钥解密得到公钥。\nps：证书签名是使用算法校验hash值的行为，不是名词！！！\n数字证书在非对称加密算法上嵌套了一层，保证其仍具有不可见性，那么它是如何保证公钥传输的不可篡改性的呢？假设数字证书被黑客截取并篡改，我们讨论以下三个场景：\n若改变数字证书的某一部分内容，证书签名即计算hash值并与证书指纹对比不通过，程序终止 若改变数字证书的内容，使得其通过数字签名，这是不可能的，比如使用原证书的信息，使用 若将数字证书替换成其他网站向CA机构申请的数字证书，证书签名通过，但证书信息如域名与所请求的服务器不一致，程序终止 综上，数字证书使用自校验的方式保证了公钥的不可篡改性，进而保证了其在公钥传输场景下的唯一性，最终实现了绝对安全性。\n完整流程 # 在论述TLS协议的完整流程前，先来简单回顾TCP的工作流程，TCP是一种提供了面向连接的、可靠字节流服务，并拥有流量控制、拥塞控制等功能的协议。在TLS协议执行之前，客户端与服务端之间会发生什么事情呢？答案是在传输层中建立连接，也就是我们通常说的三次握手过程：首先，客户端发送建立连接请求给服务端，包含\\(\\rm{SYN}_1=\\rm{ISN}_{client}\\)（即同步字段）；服务端接收请求后，会构建请求回复客户端，其中\\(\\rm{SYN}_2=\\rm{ISN}_{server}\\)，\\(\\rm{ACK}_2=\\rm{SYN}_1+1\\)（即确认字段，确认收到的是刚才的请求）；最后，客户端接收到服务端的请求，再次构建请求回复服务端，其中\\(\\rm{SYN}_3=\\rm{SYN}_1+1\\)，\\(\\rm{ACK}_3=\\rm{SYN}_2+1\\)，这便完成了三次握手。由于TCP不是本文的论述重点，关于协议内容，涉及的算法原理、四次挥手等不再赘述，感兴趣的读者可自行了解。\n因此，TLS协议完整流程如下：服务端预先准备好公钥和网络数字身份，并成功向CA机构申请数字证书（1）。TCP通过三次握手建立连接（2），接着TLS进行两次握手：首先，客户端向服务端发送一个client hello消息，并传输相应的TLS版本和支持的加密算法；服务端收到回应后发送一个server hello消息，传输将要采用的TLS版本并选择最佳加密算法，此时握手完成。服务端向客户端发送由CA机构颁布的数字证书（3）。客户端接收数字证书后，首先通过hash算法验证证书签名，以确保其完整性（如分别计算CA私钥加密的公钥、证书内容的hash值，将其合并与证书指纹进行对比），接着通过操作系统自带的CA公钥解密得到公钥，确保其真实性。进一步地，客户端生成预主密钥，通过公钥加密预主密钥（4），并将其发送给服务端（5）。服务端接收后用私钥解密（6），最终实现仅双方可见的预主密钥场景，如下图所示：\n注：数字证书保证了公钥的不可篡改性，但没有保证其不可见性，原因在于：虽然公钥经过CA私钥加密，但大部分操作系统上都含有解密的CA公钥，对于黑客来说，公钥仍然是可见的。再根据原理及流程中论述的非对称加密过程，我们知道仅仅可见公钥对于破解预主密钥没有帮助，所以数字证书可以保证公钥传输的绝对安全性\n参考 # https://blog.csdn.net/liweiny/article/details/137564206\nhttps://www.bilibili.com/video/BV1h1421y7YH/?vd_source=49a9f7cbff0f0e8494f93d68e40df4fd\nhttps://info.support.huawei.com/info-finder/encyclopedia/zh/SSL.html\n","date":"2024-10-13","externalUrl":null,"permalink":"/blog/learn/computer-network/ssl-tls/","section":"学习","summary":"SSL/TLS加密传输协议学习笔记","title":"加密传输协议SSL/TLS","type":"learn"},{"content":"从高中到本科，我一直没有记笔记的习惯，学习时，顶多在书上勾勒几行或写下几个关键词，却从未真正通过纸笔将知识记录下来。高中阶段，知识的广度较窄，深度也不足以通过笔记来掌握（或者说依赖于刷题积累）。应试教育的影响下，我更专注于做题，而忽略了知识的归纳和整理，幸运的是，这并没有对最后的成绩（高考分数）造成多大的影响。\n进入本科后，我依然保持着这种”坏”习惯，但逐渐感到力不从心。过去我依靠强大短期的记忆力迅速学习新知识，但随着课程内容的增加和知识的拓宽，许多知识只有在刚学时熟稔于心，随后几个月便会随着费曼学习曲线迅速淡忘，尤其随着年龄增长，这种情况愈发明显。这样的结局是我乃至大部分人都不想面对的。\n另一方面，我的文字表达能力相对薄弱，通过文字表达的所知所想对我而言效率低下，效果也不理想。究其原因，在于前二十年对作文的不重视，除了大考，我几乎从未在限定时间内完成一篇作文，越不写就越害怕，越害怕就越不会写，这样的恶性循环伴随着我整个求学生涯。\n如今，作为一名计算机专业的学生，“活到老，学到老”是我们这一行（或许对于所有行业都一样？）耳熟能详的格言，这使我不得不开始重视记录的重要性。\n种一棵树最好的时间是十年前，其次是现在\n所幸，这一切都不算太晚。除了提升文字表达能力，学会记录能够帮助我更好地梳理逻辑，形成一套完整的工作体系。搭建自己的个人博客，一方面是希望我少玩手机，多去记录所见所想；另一方面是为了记录所学知识，加深理解，传播知识以帮助到大家。不想当艺术家的程序员不是好程序员，程序员在编程的过程中同样需要艺术家的创造力和对美的需求，写作是基本，也是不可获取的重要组成部分，在写作过程中，富有创造力、追求美感，全身心投入这些精神与其相辅相成。我相信，终有一天，这些努力会开花结果的。\n","date":"2024-10-12","externalUrl":null,"permalink":"/blog/myself/blog_reason/","section":"关于自己","summary":"","title":"个人博客初衷","type":"myself"},{"content":"欢迎来到我的网站！非常高兴能与您在此相遇。这一部分是我在成长过程中积累的感悟，希望通过文字记录人生所见、所想所悟，既是对过往的总结，也是对当下的思考，更是对未来的展望。这里的内容没有固定的格式，更多的是随心所写，或许大多数只是些琐碎的思绪，但我希望这些点滴能与您产生共鸣。\n","date":"2024-10-12","externalUrl":null,"permalink":"/blog/myself/","section":"关于自己","summary":"","title":"关于自己","type":"myself"},{"content":" 前言 # 此为研究生课程模式识别的第一次作业，求多元正态分布下关于\\(\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}\\)的极大似然估计值。本文用于记录相关公式及推导过程，内容涉及极大似然估计、矩阵求导等。\n正态分布 # 众所周知，正态分布的概率密度函数为\\(f(x)=\\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp[-\\frac{(x-\\mu)^2}{2}]\\)。令\\(x_i \\sim N(\\mu,\\sigma^2)\\)，\\(\\mathcal{D}=\\set{x_1,x_2,\\cdots,x_n}\\)，则极大似然函数为 $$ L(\\mu,\\sigma^2)=\\prod_{i=1}^n f(x_i)=\\frac{1}{(2\\pi \\sigma^2)^{\\frac{n}{2}}}\\exp [-\\frac{1}{2} \\sum_{i=1}^n (x_i-\\mu)^2 ] $$ 对极大似然取对数，再求导并令\\(\\frac{\\partial{\\ln L(\\mu,\\sigma^2)}}{\\partial \\mu}=0,\\frac{\\partial{\\ln L(\\mu,\\sigma^2)}}{\\partial \\sigma^2}=0\\)，解得\\(\\hat{\\mu}=\\bar{x},\\sigma^2=\\frac{1}{n}\\sum_{i=0}^n (x-\\bar{x})^2=\\frac{1}{n}\\sum_{i=0}^n (x-\\hat{\\mu})^2\\)\n多元正态分布 # 假设\\( \\boldsymbol{x}_i \\in \\mathbb{R}^p, \\boldsymbol{u} \\in \\mathbb{R}^p,\\boldsymbol{\\Sigma} \\in \\mathcal{S}_{+}^p \\) ，且\\(\\boldsymbol{x}_i \\sim \\mathcal{N}_p(\\boldsymbol{\\mu},\\boldsymbol{\\Sigma})\\)，令\\(\\mathcal{D}=\\set{\\boldsymbol{x}_1,\\boldsymbol{x}_2,\\cdots,\\boldsymbol{x}_n}\\)，则多元形式下的正态分布概率密度函数为：\n$$ f(\\boldsymbol{x})= \\frac{1}{(2\\pi)^\\frac{p}{2} | \\boldsymbol{\\Sigma}|^\\frac{1}{2}} \\exp[{-\\frac{1}{2}} (\\boldsymbol{x-u})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x-u})] $$ 对其取对数，并进行化简： $$ \\ln{L(\\boldsymbol{u},\\boldsymbol{\\Sigma})}=-\\frac{pn}{2}\\ln(2\\pi) -\\frac{n}{2}\\ln|\\boldsymbol{\\Sigma}|-\\frac{1}{2}\\sum_{i=1}^n {(\\boldsymbol{x_i-u})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x_i-u})} $$\n矩阵求导公式 # 下面给出几个后续证明推导要用到的公式，由于不是本文重点，此处不对其进行证明\n$$ \\frac{\\partial{\\ln{|\\boldsymbol{X}|}}}{\\partial{\\boldsymbol {X}}}=\\boldsymbol{X^{-T}} \\tag{1} $$\n$$ \\frac{\\partial{\\ln(\\boldsymbol{\\lambda^T X^{-1}\\lambda})}}{\\partial{\\boldsymbol{X}}}=-(\\boldsymbol{X^{-1} \\lambda \\lambda^T X^{-1}})^T \\tag{2} $$\n$$ \\frac{\\partial{(\\boldsymbol{\\lambda-x})^T \\boldsymbol{\\Sigma^{-1}} (\\boldsymbol{\\lambda-x})}}{\\partial{\\boldsymbol{x}}}=[\\boldsymbol{(\\lambda-x)^T (\\Sigma^{-T}+\\Sigma^{-1})}]^T \\tag{3} $$\n记\\( \\frac{\\partial{f(\\boldsymbol{X})}}{\\partial{\\boldsymbol{X}}}=\\boldsymbol{A} \\)，其中\\(\\boldsymbol{X} \\in \\mathbb{R}^{n \\times n} ,f:\\mathbb{R}^{n \\times n} \\rightarrow \\mathbb{R}\\)。因此对于\\(\\boldsymbol{X} \\in S^n\\)，有： $$ \\frac{\\partial{f(\\boldsymbol{X})}}{\\partial{\\boldsymbol{X}}}=\\boldsymbol{A^T +A - A\\circ E} \\tag{4} $$ 其中\\(\\circ\\)为Hadamard product。这表明了对称矩阵在求导过程中的特殊性。\n由于\\(\\boldsymbol{X} \\in \\mathcal{S}^n\\)，则式\\((1),(2)\\)可转换为\\((5),(6)\\)：\n$$ \\frac{\\partial{\\ln{|\\boldsymbol{X}|}}}{\\partial{\\boldsymbol {X}}} =\\boldsymbol{X^{-1}}+\\boldsymbol{X^{-T}}-\\boldsymbol{X^{-T}}\\circ \\boldsymbol{E} \\tag{5} $$\n$$ \\begin{aligned} \\frac{\\partial{\\ln(\\boldsymbol{\\lambda^T X^{-1}\\lambda})}}{\\partial{\\boldsymbol{X}}} =\u0026amp;-(\\boldsymbol{X^{-1} \\lambda \\lambda^T X^{-1}}) -(\\boldsymbol{X^{-1} \\lambda \\lambda^T X^{-1}})^T \\newline \u0026amp;+(\\boldsymbol{X^{-1} \\lambda \\lambda^T X^{-1}})^T \\circ \\boldsymbol{E} \\tag{6} \\end{aligned} $$\n由式\\((3)\\)可得：\n$$ \\begin{aligned} \\frac{\\partial{\\ln{L(\\boldsymbol{u},\\boldsymbol{\\Sigma})}}}{\\partial{\\boldsymbol{u}}} \u0026amp;=-\\frac{1}{2} \\sum_{i=0}^n \\frac{\\partial{(\\boldsymbol{x_i-u})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x_i-u})}}{\\partial{\\boldsymbol{u}}} \\newline \u0026amp;=\\sum_{i=1}^n \\boldsymbol{\\Sigma^{-1}(x_i-u)} \\newline \u0026amp;=\\boldsymbol{\\Sigma^{-1} \\sum_{i=1}^n (x_i-u)} \\tag{7} \\end{aligned} $$\n由式\\((5),(6)\\)可得：\n$$ \\begin{aligned} \\frac{\\partial{\\ln{L(\\boldsymbol{u},\\boldsymbol{\\Sigma})}}}{\\partial{\\boldsymbol{\\Sigma}}} \u0026amp;=-\\frac{n}{2} \\frac{\\partial{\\ln|\\boldsymbol{\\Sigma}|}}{\\partial{\\boldsymbol{\\Sigma}}}-\\frac{1}{2} \\sum_{i=0}^n \\frac{\\partial{(\\boldsymbol{x_i-u})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x_i-u})}}{\\partial{\\boldsymbol{\\Sigma}}} \\newline \u0026amp;=\\frac{1}{2} [\\boldsymbol{\\sum_{i=0}^n (\\Sigma^{-1}(x_i-u)(x_i-u)^T \\Sigma^{-1}} -n\\boldsymbol{\\Sigma^{-1}})^T \\newline \u0026amp;+ \\boldsymbol{\\sum_{i=0}^n (\\Sigma^{-1}(x_i-u)(x_i-u)^T \\Sigma^{-1}} -n\\boldsymbol{\\Sigma^{-1}}) \\newline \u0026amp;-\\boldsymbol{\\sum_{i=0}^n (\\Sigma^{-1}(x_i-u)(x_i-u)^T \\Sigma^{-1}} -n \\boldsymbol{\\Sigma^{-1}) \\circ E }] \\newline \u0026amp;=\\boldsymbol{\\sum_{i=0}^n (\\Sigma^{-1}(x_i-u)(x_i-u)^T \\Sigma^{-1}} -n \\boldsymbol{\\Sigma^{-1})} -\\frac{1}{2} \\boldsymbol{\\sum_{i=0}^n (\\Sigma^{-1}(x_i-u)(x_i-u)^T \\Sigma^{-1}} -n \\boldsymbol{\\Sigma^{-1}) \\circ E } \\tag{8} \\end{aligned} $$\n令式\\((7)\\)等于\\(0\\)，左右两边同乘\\(\\boldsymbol{\\Sigma}^{-1}\\)，得\\(\\hat{\\boldsymbol{\\mu}}=\\sum_{i=0}^n x_i=\\bar{x}\\)，令式\\((8)\\)等于\\(\\boldsymbol{0}\\)，并把\\(\\hat{\\boldsymbol{\\mu}}\\)带入式\\((8)\\)，得\\(\\boldsymbol{\\hat{\\Sigma}} =\\frac{1}{n} \\sum_{i=1}^n (\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})^T=\\frac{1}{n} \\sum_{i=1}^n (x_i-\\hat{\\boldsymbol{\\mu}})(x_i-\\hat{\\boldsymbol{\\mu}})^T\\)。综上，多元正态分布的极大似然估计值\\(\\hat{\\boldsymbol{\\mu}}\\)为样本的矩阵，而\\(\\boldsymbol{\\hat{\\Sigma}}\\)为样本的协方差矩阵。\n","date":"2023-10-14","externalUrl":null,"permalink":"/blog/learn/%E5%A4%9A%E5%85%83%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/","section":"学习","summary":"模式识别第一次作业——多元正态分布的极大似然估计","title":"多元正态分布极大似然估计","type":"learn"},{"content":"","date":"2023-10-14","externalUrl":null,"permalink":"/blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习","type":"tags"},{"content":"","date":"2023-10-14","externalUrl":null,"permalink":"/blog/tags/%E6%95%B0%E5%AD%A6/","section":"Tags","summary":"","title":"数学","type":"tags"},{"content":"","externalUrl":null,"permalink":"/blog/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"QQ Email：1094554173@qq.com\n","externalUrl":null,"permalink":"/blog/email/","section":"Yuki","summary":"","title":"邮箱","type":"page"},{"content":"欢迎来到我的生活小站！\n","externalUrl":null,"permalink":"/blog/life/","section":"这是Yuki，欢迎来到我的生活小站!","summary":"","title":"这是Yuki，欢迎来到我的生活小站!","type":"life"}]